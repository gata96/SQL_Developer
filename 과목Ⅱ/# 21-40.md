### DDL - card
|CREATE|ALTER|RENAME|DROP|
|-|-|-|-|
테이블 만들기|데이터 입력|테이블명 변경|컬럼 삭제

```SQL
1. 테이블에 데이터를 입력하는 두 가지 유형

INSERT INTO 테이블명 VALUES (값1,값2,값3...)
-- 컬럼 개수에 맞게 값을 넣어야한다.

INSERT INTO 테이블명 (col1,col2,col3,..) VALUES (값1,값2,값3...)
-- 테이블명 뒤에 컬럼만 추가

2. 데이터 수정하기

UPDATE 테이블명 SET 수정할 컬럼 = 수정되길 원하는 값 WHERE 컬럼 = ''
-- WHERE 절이 없으면 해당 컬럼이 전부 수정됨
```
### DELETE, DROP, TRUNCATE 차이
삭제|데이터|디스크 초기화|테이블|
-|-|-|-|
DELETE|✔️|❌|❌|
TRUNCATE|✔️|✔️|❌|
DROP|✔️|✔️|✔️|


💡DELETE, DROP, TRUNCATE 모두 데이터를 삭제하지만,
삭제한 데이터에 대한 **로그**를 남기는 것은 **DELETE 만** 가능하다.
```SQL
DELETE FROM 테이블명
DROP TABLE 테이블명
TRUNCATE TABLE 테이블명
```
주의 '*'가 붙지 않는다.

![image](https://github.com/gata96/SQL_Developer/assets/121420427/71c8118c-a79d-40fc-88f6-950829b5c2c2)

![image](https://github.com/gata96/SQL_Developer/assets/121420427/855d2dfc-88ab-423c-852d-b4f67082d4c4)

트랜잭션을 수행하고 LOG DB에 쌓아뒀다가, 일정 시간이 지나서 어느정도 쌓이면 DB가 실제 디스크에 동기화 작업을 실행한다.


로그가 있어야 ROLLBACK을 했을 때 그 시점의 데이터로 돌아갈 수 있는데, DROP과 TRUNCATE의 경우 로그가 없기 때문에(= UNDO를 위한 데이터를 생성하지 않기 때문에) ROLLBACK이 불가능하고, 삭제 시 DELETE 보다 빠르다.

또한, DROP과 TRUNCATE는 바로 반영이 되는 AUTO COMMIT이고, DELETE는 사용자 COMMIT으로 수행된다.

<BR>

### 중복 제거 : DISTINCT

```SQL
SELECT DISTINCT COL1,COL2, FROM TABLE;
```

### 트랜잭션의 특성 (ACID)
1. 원자성 (Automicity) : 트랜잭션에서 정의된 연산들은 모두 수행되던지, 전혀 실행되지 않은 상태로 남아있어야한다. (All or Nothing)
2. 일관성 (Consistency) : 트랜잭션이 실행되기 전에 데이터베이스의 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터 베이스의 내용에 잘못이 있으면 안된다.
3. 고립성 (Isolation) : 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아서 잘못된 결과를 만들어서는 안된다.
4. 지속성 (Durability): 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터 베이스의 내용은 영구적으로 저장된다.
