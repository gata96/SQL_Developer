# 제 1절. 성능 데이터 모델링
- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용이 증가한다.
- 데이터모델은 성능을 튜닝하면서 변경될 수 있다.
- 분석/설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능 저하에 따른 Rework 비용을 최소화 할 수 있다.

## 성능 데이터 모델링 고려사항

① 데이터 모델링을 할 때 정규화를 정확하게 수행한다.

② 데이터베이스 용량산정을 수행한다.

③ 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.

④ 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.

⑤ 이력데이터(대량데이터)의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.

⑥ 성능관점에서 데이터 모델을 검증한다.

# 제 2절. 정규화

## 정규화 : 중복된 사항을 제거하는 것

## 정규화의 단계

### 1차 정규화 : "모든 속성은 반드시 하나의 속성값만 가져야한다." 반복되거나 중복되는 속성값을 분류하는 작업
![image](https://github.com/gata96/SQL_Developer/assets/121420427/9c21ba31-9563-45b2-ac0e-7d0ae9d89204)
![image](https://github.com/gata96/SQL_Developer/assets/121420427/396f993a-b1bb-446b-bc2c-a5dc5e1b8ba2)

### 2차 정규화 : "모든 속성은 반드시 기본키에 종속되어야 하며 테이블당 기본키(PK)는 하나이다."
#### `⭐PK 2개면 무조건 2차 정규화 실시해야한다.` 
![image](https://github.com/gata96/SQL_Developer/assets/121420427/299c05ae-0bc3-4796-bf13-961f8650aaf1)


### 3차 정규화 : 기본키가 아닌 다른 속성들끼리 서로 종속되어서는 안된다.
![image](https://github.com/gata96/SQL_Developer/assets/121420427/779a1b82-1fed-40a7-b14e-09e131518d1e)


# 제 3절. 반정규화

# 반정규화
- 반정규화는 성능향상을 위해 정규화를 포기하는 것
- BUT! 데이터 무결성(데이터의 정확성과 일관성을 유지하고 보증하는 것)이 보장 되지 않으므로 제한적으로 사용해야 한다.

## 1. 테이블 반정규화
- 테이블 병합/분할/추가

### 테이블 병합: 비지니스 로직상 JOIN 되는 경우가 많아 통합하는 것이 성능측면에서 유리할 경우 고려
- 조회 성능은 향상 되나 과도한 데이터가 한 테이블에 있으므로 용량이 너무 커지는 단점이 있다.

#### 1) 1:1 관계 테이블 병합
#### 2) 1:M 관계 테이블 병합
#### 3) 슈퍼 서브 타입 테이블 병합
![image](https://github.com/gata96/SQL_Developer/assets/121420427/cf54efc7-0349-441c-93f3-26a76fbf382b)

### 테이블 분할
#### 1) 수직 분할 : 컬럼단위로 테이블을 1:1로 분리
![image](https://github.com/gata96/SQL_Developer/assets/121420427/97b47d8a-835f-489f-bc2e-f8e6de873ac2)

#### 2) 수평 분할 : ROW 단위로 테이블을 분리
![image](https://github.com/gata96/SQL_Developer/assets/121420427/f30ec0c5-b07e-4344-ab72-bbc9a53cfbd2)

### 테이블 추가
#### 1) 중복 테이블 추가 
- 타 업무 또는 타 서버에 있는 테이블과 동일한 구조의 테이블을 추가, 원격 JOIN 방지
![image](https://github.com/gata96/SQL_Developer/assets/121420427/dc004912-487b-45d2-82aa-14438abe9257)

#### 2) 통계 테이블 추가
- 통계값을 미리 계산해서 저장하는 테이블 추가
![image](https://github.com/gata96/SQL_Developer/assets/121420427/9356a07f-b15a-432c-9a39-2bae86912d61)

#### 3) 이력테이블 추가
- 마스터 테이블에 존재하는 ROW를 트랜잭션 발생 시점에 따라 복사해두는 테이블 추가

#### 4) 부분 테이블 추가
- 자주 조회되는 컬럼들만 별도로 모아놓은 테이블 추가
- `인싸들만 모아놓은 테이블`

## 2. 칼럼 반정규화
- 중복/파생/이력테이블 컬럼 추가

### 중복 컬럼 추가
- JOIN 프로세를 줄이기 위해 중복 컬럼을 추가
- SELECT 비용은 감소하나, UPDATE 비용은 증가
![image](https://github.com/gata96/SQL_Developer/assets/121420427/55f207d1-2069-45e5-b326-08fd4a97adf1)

### 파생컬럼 추가
- 계산을 통해 얻어지는 결과값을 테이블에 컬럼으로 저장
![image](https://github.com/gata96/SQL_Developer/assets/121420427/ebc156f1-52a2-430c-b650-9ab2ced007ce)

### 이력테이블 컬럼 추가
- 이력 테이블에 기능성 컬럼 추가(최신여부, 시작일/종료일 등)
![image](https://github.com/gata96/SQL_Developer/assets/121420427/cd910e14-b2c9-4f4e-b998-015cb5213f46)


# 제 4절. 대량 데이터에 따른 성능

## ⭐하나의 큰 테이블에 대량의 데이터나 많은 수의 칼럼이 존재 할 경우 = JOIN 많이 발생 = 디스크 I/O를 많이 유발 = 성능 저하 ----> 테이블을 분리하는 것이 좋은 방법

## 로우체이닝(Row Chaining) 
- 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
- 로우 체이닝과 로우 마이그레이션이 발생하면 불필요하게 I/O가 많이 발생하여 성능이 저하된다.

## 파티셔닝
- 하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇개로 쪼개도 성능이 저하되는 경우가 있다. 이때, `하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리`하여 데이터 성능을 개선시키는 기법을 `파티셔닝`이라고 한다.

# 제 5절. 데이터베이스 구조와 성능

## 1. 슈퍼/서브타입의 데이터 모델 세가지

#### 1) 1:1 타입(One to One Type)

#### 2) 슈퍼 + 서브타입(Plus Type)

#### 3) All in One타입(Single Type)

![image](https://github.com/gata96/SQL_Developer/assets/121420427/7e68b94e-dbea-4bf3-b1c7-dec8ef0f6070)

## 슈퍼/서브타입에 대한 변환을 잘못했을 때 발생하는 오류들
#### 1) 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능이 저하될 수 있다.

#### 2) 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터 때문에 성능이 저하된다.


#### 3) 트랜잭션은 항상 슈퍼+서브타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어있어 성능이 저하된다.



## 슈퍼/서브 타입 데이터 모델의 변환기술
#### 1) 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
#### 2) 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
#### 3) 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성

#### 슈퍼/서브타입에 대한 변환을 할 때, 트랜잭션의 유형과 데이터 양을 고려하여 변환하여야한다. 데이터의 양이 소량일 경우 성능에 영향을 미치지 않기 때문에 데이터처리의 유연성을 고려하여 1:1관계를 유지한다.

## 2. PK 인덱스로 데이터베이스 성능향상
- PK순서를 지정하는데 있어서 앞쪽에 위치한 속성 값이 가급적 '=' 아니면 'BETWEEN' 이나 '<>'가 들어와야 앞에서부터 데이터를 거르고, 걸러진 데이터를 뒤져보는 형태로 작동하므로 성능의 효과가 높아지게 된다.

- '='(EQUAL 조건) 부터 맨 처음 위치로 옮기면 효율이 좋아진다.

# 제 6절. 분산 데이터베이스와 성능

## 분산 데이터베이스의 정의
- 여러 곳으로 분산되어있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스

분산데이터 베이스 환경에서 분산 설계를 적용하여 효율성이 증대되는 것
- 공통코드, 기준 정보 등 과 같은 마스터 데이터를 한 곳에 두고 운영하는 경우, 원격지에서의 접근이 빈번할 수록 업무처리 성능이 안좋아질수 있다. 그래서 분산환경에 복제 분산을 실행한다.
- 실시간 (REAL TIME)의 업무 성격을 갖고 있을 때 분산 데이터베이스를 사용한다.
- 백업 사이트를 만들때 간단하게 분산기능을 적용할 수 있다.
- Global Single Instance와는 정반대 개념이다.